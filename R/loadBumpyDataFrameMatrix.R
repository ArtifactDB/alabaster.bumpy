#' Load a BumpyDataFrameMatrix object
#'
#' Load a \linkS4class{BumpyDataFrameMatrix} object based on its metadata.
#'
#' @param assay.info Named list of metadata for the BumpyDataFrameMatrix, generated by the corresponding \code{\link{stageObject}} method.
#' @inheritParams alabaster.base::loadObject
#'
#' @return A \linkS4class{BumpyDataFrameMatrix} object.
#'
#' @author Aaron Lun
#'
#' @export
#' @importFrom BumpyMatrix BumpyMatrix
#' @importFrom alabaster.base .loadObject acquireFile acquireMetadata loadDataFrame .quickReadCsv
#' @importFrom IRanges PartitioningByWidth
#' @importFrom Matrix sparseMatrix
#' @importFrom BiocGenerics relist
loadBumpyDataFrameMatrix <- function(assay.info, project) { 
    concat.meta <- acquireMetadata(project, assay.info$bumpy_data_frame_matrix$concatenated$resource$path)
    concatenated <- .loadObject(concat.meta, project)

    dimnames <- list(NULL, NULL)
    dimnames_names <- c("row_names", "column_names")
    for (d in 1:2) {
        if (!is.null(dim.info <- assay.info$bumpy_matrix[[dimnames_names[d]]])) {
           dim.meta <- acquireMetadata(project, dim.info$resource$path)
            dimnames[[d]] <- .loadObject(dim.meta, project)[,1]
        }
    }

    group.path <- acquireFile(project, assay.info$path)
    groupings <- .quickReadCsv(group.path, 
        expected.columns=c(row="integer", column="integer", number="integer"),
        expected.nrows=assay.info$bumpy_matrix$object_count,
        row.names=isTRUE(assay.info$bumpy_matrix$object_names),
        compression=assay.info$bumpy_matrix$compression
    )

    dfl <- relist(concatenated, PartitioningByWidth(x = groupings$number))
    if (!is.null(rownames(groupings))) {
        names(dfl) <- rownames(groupings)
    }

    dims <- assay.info$array$dimensions
    if (dims[[1]] * dims[[2]] > nrow(groupings)) {
        mat <- sparseMatrix(i=groupings$row, j=groupings$column, x=seq_len(nrow(groupings)), dims=dims, dimnames=dimnames)
    } else {
        mat <- matrix(0L, dims[[1]], dims[[2]], dimnames=dimnames)
        mat[as.matrix(groupings[,c("row", "column")])] <- seq_len(nrow(groupings))
    }

    BumpyMatrix(x = dfl, proxy = mat)
}
